Репозиторий длф семинара
===

Нюансы:
1. При коротком объявлении создается новая переменна в текущем контексте, игнорируя существование одноименной переменной
2. Iota поддерживает вычисления
3. make создает буферный тип, а new ссылку на тип с нулевыми значениями
4. Slice хранит ссылку на массив, ссылка копируется и при операциях над срезами
5. Если не указывать значение при объявлении переменной явно, то оно будет установлено в значение по-умолчанию
6. По ссылке всегда передаются срезы, хэш-таблицы, каналы и функции
7. На самом деле в Go нет передаче по ссылке, все передается по значению
8. Горутины получают значения захваченных переменных в момент исполнения
9.1. Закрытый канал возвращает значение по-умолчанию 
9.2. Попытка записи в закрытый канал вызовет панику
9.3. select работает со всеми каналами одновременно, заблокировать ветвь можно установлением канала в nil
10. Граф зависимостей пакетов должен быть ациклическим, поэтому main нельзя нигде импортировать, а так же не может быть кросс-зависимостей

Рекомендации:
1. Бывает сложно написать тест на функцию main, поэтому рекомендуется делать её как можно меньше
2. Тестировать будет удобнее, если объекты уровня пакета устанавливаются через Lazy Initialization, а не функцию init
3. В идеале вообще не использовать переменные уровня пакета и функцию init
4. Неплохая структура приложения https://github.com/golang-standards/project-layout

